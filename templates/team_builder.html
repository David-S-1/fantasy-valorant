<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Valorant Fantasy Team Builder</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .role-D { background: #f87171; }
    .role-I { background: #60a5fa; }
    .role-S { background: #fbbf24; }
    .role-C { background: #34d399; }
    .role-badge { font-weight: bold; padding: 0.2em 0.6em; border-radius: 0.5em; color: #fff; }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
  <div class="max-w-5xl mx-auto p-4">
    <h1 class="text-3xl font-bold mb-2">Build Your Valorant Fantasy Team</h1>
    <p class="mb-4 text-gray-300">Select 8 players (2 Duelists, 2 Initiators, 2 Sentinels, 2 Controllers). Stay under the budget. Name your team and submit!</p>
    <div class="mb-4">
      <label class="block mb-1 font-semibold" for="teamName">Team Name:</label>
      <input id="teamName" class="p-2 rounded text-black w-full max-w-xs" placeholder="Enter your team name...">
    </div>
    <div class="mb-4 flex flex-wrap gap-2">
      <button class="filter-btn role-D role-badge" data-role="D">Duelist</button>
      <button class="filter-btn role-I role-badge" data-role="I">Initiator</button>
      <button class="filter-btn role-S role-badge" data-role="S">Sentinel</button>
      <button class="filter-btn role-C role-badge" data-role="C">Controller</button>
      <button class="filter-btn bg-gray-700 role-badge" data-role="ALL">All</button>
    </div>
    <div class="mb-4 font-bold">Budget: <span id="budget">100</span> | Used: <span id="usedPoints">0</span></div>
    <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4" id="playerList"></div>
    <h2 class="text-2xl font-bold mt-8 mb-2">Selected Players</h2>
    <div id="selectedPlayers" class="mb-4"></div>
    <button id="submitBtn" class="bg-blue-600 px-6 py-2 rounded font-bold disabled:opacity-50" disabled>Submit Team</button>
  </div>
  <script>
    // --- CONFIG ---
    const MAX_PER_ROLE = 2;
    const MAX_PLAYERS = 8;
    const MAX_BUDGET = 65;
    const ROLE_NAMES = { D: "Duelist", I: "Initiator", S: "Sentinel", C: "Controller" };
    const ROLE_ORDER = ["D", "I", "S", "C"];

    // --- STATE ---
    let allPlayers = [];
    let selected = [];
    let filterRole = "ALL";

    // --- LOAD DATA ---
    // List all player info JSONs (with roles, teams, etc.)
    // Example: ["../json/vct_2025_china_stage_2_players.json", ...]
    const playerInfoFiles = [
      "../json/vct_2025_china_stage_2_players.json",
      "../json/vct_2025_americas_stage_2_players.json",
      "../json/vct_2025_emea_stage_2_players.json",
      "../json/vct_2025_pacific_stage_2_players.json"
      // Add more player info JSON file paths here
    ];
    // List all PPG/cost JSONs (from calculate_ppg_and_costs.py)
    // Example: ["../json/vct_2025_china_stage_2_ppg_cost.json", ...]
    const playerStatsFiles = [
      "../json/vct_2025_china_stage_2_ppg_cost.json",
      "../json/vct_2025_americas_stage_2_ppg_cost.json",
      "../json/vct_2025_emea_stage_2_ppg_cost.json",
      "../json/vct_2025_pacific_stage_2_ppg_cost.json"
      // Add more PPG/cost JSON file paths here
    ];

    const cacheBust = `?v=${Date.now()}`;

    Promise.all([
      ...playerInfoFiles.map(path => fetch(path + cacheBust).then(res => res.json())),
      ...playerStatsFiles.map(path => fetch(path + cacheBust).then(res => res.json()))
    ]).then(jsons => {
      // First N are player info, rest are stats
      const infoJsons = jsons.slice(0, playerInfoFiles.length);
      const statsJsons = jsons.slice(playerInfoFiles.length);

      // Merge all player info into one dict
      const infoDict = {};
      infoJsons.forEach(data => {
        Object.entries(data).forEach(([name, p]) => {
          infoDict[name] = { ...p, name };
        });
      });
      console.log('Loaded player info names:', Object.keys(infoDict));

      // Merge all stats into one dict
      const statsDict = {};
      statsJsons.forEach(data => {
        (Array.isArray(data) ? data : Object.values(data)).forEach(p => {
          statsDict[p.name] = p;
        });
      });
      console.log('Loaded player stats names:', Object.keys(statsDict));

      // Merge by name for frontend
      allPlayers = Object.values(infoDict).map(p => ({
        ...p,
        Role: p.role, // Ensure Role is set for badge rendering
        PPG: statsDict[p.name]?.ppg ?? null,
        Cost: statsDict[p.name]?.cost ?? null
      }));
      console.log('Merged allPlayers:', allPlayers);

      renderPlayers();
      renderSelected();
      document.getElementById("budget").textContent = MAX_BUDGET;
    }).catch(err => {
      document.getElementById("playerList").innerHTML = "<div class='text-red-400'>Failed to load player data.</div>";
      console.error("Error loading player data:", err);
    });

    // --- UTILS ---
    function getUsedPoints() {
      return selected.reduce((sum, p) => sum + (p.Cost || 0), 0);
    }

    // Helper: assign UsedRole to each selected player so that each player only counts for one role, always filling the most needed role
    function assignUsedRolesToList(list) {
      // Assign roles optimally: for each player, pick the role they have that is most needed at that moment
      const counts = { D: 0, I: 0, S: 0, C: 0 };
      // First, clear all UsedRole
      list.forEach(p => { delete p.UsedRole; });
      // Sort players by number of roles (least flexible first)
      const sorted = [...list].sort((a, b) => (a.Role ? a.Role.length : 0) - (b.Role ? b.Role.length : 0));
      sorted.forEach(p => {
        const roles = p.Role ? p.Role.split("") : [];
        // Find the role among their roles with the lowest count
        let minRole = null;
        let minCount = Infinity;
        roles.forEach(r => {
          if (counts[r] < minCount) {
            minRole = r;
            minCount = counts[r];
          }
        });
        if (minRole) {
          p.UsedRole = minRole;
          counts[minRole]++;
        }
      });
    }

    function assignUsedRoles() {
      assignUsedRolesToList(selected);
    }

    // Simulate assigning roles if a player is added, and check if any role would exceed the max allowed
    function canAddPlayer(player) {
      if (selected.length >= MAX_PLAYERS) return false;
      if (selected.find(p => p.name === player.name)) return false;
      if (getUsedPoints() + (player.Cost || 0) > MAX_BUDGET) return false;
      // Simulate selection
      const simSelected = [...selected.map(p => ({...p})), {...player}];
      assignUsedRolesToList(simSelected);
      // Count roles
      const counts = { D: 0, I: 0, S: 0, C: 0 };
      simSelected.forEach(p => { if (p.UsedRole) counts[p.UsedRole]++; });
      return Object.values(counts).every(c => c <= MAX_PER_ROLE);
    }

    // --- RENDER PLAYER CARDS ---
    function renderPlayers() {
      const list = document.getElementById("playerList");
      list.innerHTML = "";
      let filtered = allPlayers;
      if (filterRole !== "ALL") {
        filtered = allPlayers.filter(p => p.Role && p.Role.includes(filterRole));
      }
      filtered.forEach(player => {
        const isSelected = selected.find(p => p.name === player.name);
        const disabled =
          isSelected ||
          !canAddPlayer(player);
        const roleArr = player.Role ? player.Role.split("") : [];
        const card = document.createElement("div");
        card.className = `rounded p-3 bg-gray-800 flex flex-col items-start border-2 border-gray-700`;
        card.innerHTML = `
          <div class="flex flex-wrap items-center mb-2 gap-1">
            ${roleArr.map(role => `<span class="role-badge role-${role}">${ROLE_NAMES[role]}</span>`).join("")}
            <span class="font-bold text-lg">${player.name}</span>
          </div>
          <div class="text-sm">Cost: <span class="font-bold">${player.Cost ?? "-"}</span></div>
          <div class="text-sm">PPG: <span class="font-bold">${typeof player.PPG === 'number' ? player.PPG.toFixed(2) : "-"}</span></div>
          <button class="mt-2 px-3 py-1 bg-green-600 rounded disabled:opacity-50" ${disabled ? "disabled" : ""}>${isSelected ? "Selected" : "Add"}</button>
        `;
        card.querySelector("button").onclick = () => addPlayer(player);
        list.appendChild(card);
      });
    }

    // --- RENDER SELECTED PLAYERS ---
    function renderSelected() {
      assignUsedRoles();
      document.getElementById("usedPoints").textContent = getUsedPoints();
      const selDiv = document.getElementById("selectedPlayers");
      if (selected.length === 0) {
        selDiv.innerHTML = '<div class="text-gray-400">No players selected yet.</div>';
        document.getElementById("submitBtn").disabled = true;
        return;
      }
      let html = "";
      ROLE_ORDER.forEach(role => {
        const group = selected.filter(p => p.UsedRole === role);
        if (group.length) {
          html += `<div class="mb-2"><span class="role-badge role-${role}">${ROLE_NAMES[role]}</span>:`;
          group.forEach(p => {
            html += ` <span class="font-bold">${p.name}</span> <span class="text-gray-400">(${p.Cost ?? '-'} )</span> <button class="text-red-400 ml-1" onclick="removePlayer('${p.name}')">&times;</button>`;
          });
          html += `</div>`;
        }
      });
      selDiv.innerHTML = html;
      // Debug log for canSubmit
      const teamName = document.getElementById("teamName").value.trim();
      const roleCounts = getRoleCounts();
      console.log('canSubmit:', canSubmit(), '| selected:', selected.map(p => p.name), '| teamName:', teamName, '| roleCounts:', roleCounts);
      document.getElementById("submitBtn").disabled = !canSubmit();
    }

    // --- ADD/REMOVE PLAYER ---
    function addPlayer(player) {
      if (selected.length >= MAX_PLAYERS) return;
      if (selected.find(p => p.name === player.name)) return;
      if (getUsedPoints() + (player.Cost or 0) > MAX_BUDGET) return;
      selected.push({...player});
      assignUsedRoles();
      renderPlayers();
      renderSelected();
    }
    window.removePlayer = function(name) {
      selected = selected.filter(p => p.name !== name);
      assignUsedRoles();
      renderPlayers();
      renderSelected();
    }

    // --- ROLE COUNTS ---
    function getRoleCounts() {
      const counts = { D: 0, I: 0, S: 0, C: 0 };
      selected.forEach(p => {
        if (p.UsedRole) counts[p.UsedRole]++;
      });
      return counts;
    }

    // --- FILTER BUTTONS ---
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.onclick = () => {
        filterRole = btn.dataset.role;
        renderPlayers();
      };
    });

    // --- SUBMIT TEAM ---
    function canSubmit() {
      if (selected.length !== 8) return false;
      const counts = getRoleCounts();
      for (const role of ROLE_ORDER) {
        if (counts[role] !== 2) return false;
      }
      const teamName = document.getElementById("teamName").value.trim();
      if (!teamName) return false;
      return true;
    }

    document.getElementById("submitBtn").onclick = () => {
      if (!canSubmit()) return;
      const teamName = encodeURIComponent(document.getElementById("teamName").value.trim());
      const playerNames = selected.map(p => encodeURIComponent(p.name)).join(",");
      window.location.href = `team_results.html?teamName=${teamName}&players=${playerNames}`;
    };
    document.getElementById("teamName").addEventListener("input", renderSelected);
  </script>
  <script>
    (function(){
      function refresh(){
        fetch('/api/points').then(r=>r.json()).then((data)=>{
          if (typeof window.renderPoints === 'function') {
            window.renderPoints(data);
          } else {
            location.reload();
          }
        }).catch(()=>{ location.reload(); });
      }
      try {
        const es = new EventSource('/api/stream');
        es.onmessage = (e)=>{ if (e.data === 'points-updated') refresh(); };
      } catch(_) {
        setInterval(refresh, 60000);
      }
    })();
  </script>
</body>
</html>
